   1               		.file	"PwmBrushless.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	PWM_SetDuty:
  13               	.LFB13:
  14               		.file 1 "src/PwmBrushless.c"
   1:src/PwmBrushless.c **** #include "PwmBrushless.h"
   2:src/PwmBrushless.c **** 
   3:src/PwmBrushless.c **** static void PWM_SetDuty(uint16_t promil);
   4:src/PwmBrushless.c **** 
   5:src/PwmBrushless.c **** static uint8_t CurrentSpeed = 0;
   6:src/PwmBrushless.c **** 
   7:src/PwmBrushless.c **** void Brushless_Calibration(void) {
   8:src/PwmBrushless.c **** 
   9:src/PwmBrushless.c ****   PWM_SetDuty(100);
  10:src/PwmBrushless.c ****   _delay_ms(8000);
  11:src/PwmBrushless.c ****   PWM_SetDuty(50);
  12:src/PwmBrushless.c ****   _delay_ms(2000);
  13:src/PwmBrushless.c **** 
  14:src/PwmBrushless.c **** }
  15:src/PwmBrushless.c **** 
  16:src/PwmBrushless.c **** void Brushless_Init(Pin* pin) {
  17:src/PwmBrushless.c **** 
  18:src/PwmBrushless.c ****   Pin_SetMode(pin, PIN_OUTPUT);
  19:src/PwmBrushless.c **** 
  20:src/PwmBrushless.c ****   *(pin->timer->TCCRnA) |= (1 << pin->timer->COMnA1) | (1 << pin->timer->WGMn1);
  21:src/PwmBrushless.c ****   *(pin->timer->TCCRnB) |= (1 << pin->timer->WGMn3) | (1 << pin->timer->CSn1);
  22:src/PwmBrushless.c ****   *(pin->timer->ICRn) = MAX_OCR;
  23:src/PwmBrushless.c **** 
  24:src/PwmBrushless.c ****   PWM_SetDuty(50);
  25:src/PwmBrushless.c ****   _delay_ms(5000);
  26:src/PwmBrushless.c **** 
  27:src/PwmBrushless.c **** }
  28:src/PwmBrushless.c **** 
  29:src/PwmBrushless.c **** // duty cycle (0 pr-1000 pr)
  30:src/PwmBrushless.c **** void PWM_SetDuty(uint16_t promil) {
  15               		.loc 1 30 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  31:src/PwmBrushless.c **** 
  32:src/PwmBrushless.c ****   if(promil > 100) {
  22               		.loc 1 32 0
  23 0000 8536      		cpi r24,101
  24 0002 9105      		cpc r25,__zero_reg__
  25 0004 00F4      		brsh .L3
  33:src/PwmBrushless.c ****     promil = 100;
  34:src/PwmBrushless.c ****   } else if(promil < 50) {
  26               		.loc 1 34 0
  27 0006 8233      		cpi r24,50
  28 0008 9105      		cpc r25,__zero_reg__
  29 000a 00F4      		brsh .L2
  35:src/PwmBrushless.c ****     promil = 50;
  30               		.loc 1 35 0
  31 000c 82E3      		ldi r24,lo8(50)
  32 000e 90E0      		ldi r25,0
  33               	.LVL1:
  34 0010 00C0      		rjmp .L2
  35               	.LVL2:
  36               	.L3:
  33:src/PwmBrushless.c ****     promil = 100;
  37               		.loc 1 33 0
  38 0012 84E6      		ldi r24,lo8(100)
  39 0014 90E0      		ldi r25,0
  40               	.LVL3:
  41               	.L2:
  36:src/PwmBrushless.c ****   }
  37:src/PwmBrushless.c **** 
  38:src/PwmBrushless.c ****   uint16_t duty = 20 * promil;
  42               		.loc 1 38 0
  43 0016 44E1      		ldi r20,lo8(20)
  44 0018 489F      		mul r20,r24
  45 001a 9001      		movw r18,r0
  46 001c 499F      		mul r20,r25
  47 001e 300D      		add r19,r0
  48 0020 1124      		clr __zero_reg__
  49               	.LVL4:
  39:src/PwmBrushless.c **** 
  40:src/PwmBrushless.c ****   OCR1A = duty;
  50               		.loc 1 40 0
  51 0022 3093 8900 		sts 136+1,r19
  52 0026 2093 8800 		sts 136,r18
  53 002a 0895      		ret
  54               		.cfi_endproc
  55               	.LFE13:
  57               	.global	Brushless_Calibration
  59               	Brushless_Calibration:
  60               	.LFB11:
   7:src/PwmBrushless.c **** 
  61               		.loc 1 7 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  67               	.LVL5:
  68               	.LBB21:
  69               	.LBB22:
  70               		.loc 1 40 0
  71 002c E8E8      		ldi r30,lo8(-120)
  72 002e F0E0      		ldi r31,0
  73 0030 80ED      		ldi r24,lo8(-48)
  74 0032 97E0      		ldi r25,lo8(7)
  75 0034 9183      		std Z+1,r25
  76 0036 8083      		st Z,r24
  77               	.LVL6:
  78               	.LBE22:
  79               	.LBE21:
  80               	.LBB23:
  81               	.LBB24:
  82               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  83               		.loc 2 163 0
  84 0038 24E5      		ldi r18,lo8(21333332)
  85 003a 35E8      		ldi r19,hi8(21333332)
  86 003c 85E4      		ldi r24,hlo8(21333332)
  87 003e 91E0      		ldi r25,hhi8(21333332)
  88 0040 2150      	1:	subi r18,1
  89 0042 3040      		sbci r19,0
  90 0044 8040      		sbci r24,0
  91 0046 9040      		sbci r25,0
  92 0048 01F4      		brne 1b
  93 004a 00C0      		rjmp .
  94 004c 00C0      		rjmp .
  95 004e 0000      		nop
  96               	.LVL7:
  97               	.LBE24:
  98               	.LBE23:
  99               	.LBB25:
 100               	.LBB26:
 101               		.loc 1 40 0
 102 0050 88EE      		ldi r24,lo8(-24)
 103 0052 93E0      		ldi r25,lo8(3)
 104 0054 9183      		std Z+1,r25
 105 0056 8083      		st Z,r24
 106               	.LVL8:
 107               	.LBE26:
 108               	.LBE25:
 109               	.LBB27:
 110               	.LBB28:
 111               		.loc 2 163 0
 112 0058 2FEF      		ldi r18,lo8(6399999)
 113 005a 37EA      		ldi r19,hi8(6399999)
 114 005c 81E6      		ldi r24,hlo8(6399999)
 115 005e 2150      	1:	subi r18,1
 116 0060 3040      		sbci r19,0
 117 0062 8040      		sbci r24,0
 118 0064 01F4      		brne 1b
 119 0066 00C0      		rjmp .
 120 0068 0000      		nop
 121 006a 0895      		ret
 122               	.LBE28:
 123               	.LBE27:
 124               		.cfi_endproc
 125               	.LFE11:
 127               	.global	Brushless_Init
 129               	Brushless_Init:
 130               	.LFB12:
  16:src/PwmBrushless.c **** 
 131               		.loc 1 16 0
 132               		.cfi_startproc
 133               	.LVL9:
 134 006c CF93      		push r28
 135               	.LCFI0:
 136               		.cfi_def_cfa_offset 3
 137               		.cfi_offset 28, -2
 138 006e DF93      		push r29
 139               	.LCFI1:
 140               		.cfi_def_cfa_offset 4
 141               		.cfi_offset 29, -3
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 2 */
 145               	.L__stack_usage = 2
 146 0070 EC01      		movw r28,r24
  18:src/PwmBrushless.c **** 
 147               		.loc 1 18 0
 148 0072 61E0      		ldi r22,lo8(1)
 149 0074 0E94 0000 		call Pin_SetMode
 150               	.LVL10:
  20:src/PwmBrushless.c ****   *(pin->timer->TCCRnB) |= (1 << pin->timer->WGMn3) | (1 << pin->timer->CSn1);
 151               		.loc 1 20 0
 152 0078 EF81      		ldd r30,Y+7
 153 007a F885      		ldd r31,Y+8
 154 007c A081      		ld r26,Z
 155 007e B181      		ldd r27,Z+1
 156 0080 9C91      		ld r25,X
 157 0082 21E0      		ldi r18,lo8(1)
 158 0084 30E0      		ldi r19,0
 159 0086 B901      		movw r22,r18
 160 0088 0484      		ldd r0,Z+12
 161 008a 00C0      		rjmp 2f
 162               		1:
 163 008c 660F      		lsl r22
 164 008e 771F      		rol r23
 165               		2:
 166 0090 0A94      		dec r0
 167 0092 02F4      		brpl 1b
 168 0094 A901      		movw r20,r18
 169 0096 0184      		ldd r0,Z+9
 170 0098 00C0      		rjmp 2f
 171               		1:
 172 009a 440F      		lsl r20
 173 009c 551F      		rol r21
 174               		2:
 175 009e 0A94      		dec r0
 176 00a0 02F4      		brpl 1b
 177 00a2 862F      		mov r24,r22
 178 00a4 842B      		or r24,r20
 179 00a6 892B      		or r24,r25
 180 00a8 8C93      		st X,r24
  21:src/PwmBrushless.c ****   *(pin->timer->ICRn) = MAX_OCR;
 181               		.loc 1 21 0
 182 00aa EF81      		ldd r30,Y+7
 183 00ac F885      		ldd r31,Y+8
 184 00ae A281      		ldd r26,Z+2
 185 00b0 B381      		ldd r27,Z+3
 186 00b2 8C91      		ld r24,X
 187 00b4 A901      		movw r20,r18
 188 00b6 0384      		ldd r0,Z+11
 189 00b8 00C0      		rjmp 2f
 190               		1:
 191 00ba 440F      		lsl r20
 192 00bc 551F      		rol r21
 193               		2:
 194 00be 0A94      		dec r0
 195 00c0 02F4      		brpl 1b
 196 00c2 0684      		ldd r0,Z+14
 197 00c4 00C0      		rjmp 2f
 198               		1:
 199 00c6 220F      		lsl r18
 200 00c8 331F      		rol r19
 201               		2:
 202 00ca 0A94      		dec r0
 203 00cc 02F4      		brpl 1b
 204 00ce 242B      		or r18,r20
 205 00d0 282B      		or r18,r24
 206 00d2 2C93      		st X,r18
  22:src/PwmBrushless.c **** 
 207               		.loc 1 22 0
 208 00d4 EF81      		ldd r30,Y+7
 209 00d6 F885      		ldd r31,Y+8
 210 00d8 0680      		ldd __tmp_reg__,Z+6
 211 00da F781      		ldd r31,Z+7
 212 00dc E02D      		mov r30,__tmp_reg__
 213 00de 80E2      		ldi r24,lo8(32)
 214 00e0 9EE4      		ldi r25,lo8(78)
 215 00e2 9183      		std Z+1,r25
 216 00e4 8083      		st Z,r24
 217               	.LVL11:
 218               	.LBB33:
 219               	.LBB34:
 220               		.loc 1 40 0
 221 00e6 88EE      		ldi r24,lo8(-24)
 222 00e8 93E0      		ldi r25,lo8(3)
 223 00ea 9093 8900 		sts 136+1,r25
 224 00ee 8093 8800 		sts 136,r24
 225               	.LVL12:
 226               	.LBE34:
 227               	.LBE33:
 228               	.LBB35:
 229               	.LBB36:
 230               		.loc 2 163 0
 231 00f2 2FEF      		ldi r18,lo8(15999999)
 232 00f4 83E2      		ldi r24,hi8(15999999)
 233 00f6 94EF      		ldi r25,hlo8(15999999)
 234 00f8 2150      	1:	subi r18,1
 235 00fa 8040      		sbci r24,0
 236 00fc 9040      		sbci r25,0
 237 00fe 01F4      		brne 1b
 238 0100 00C0      		rjmp .
 239 0102 0000      		nop
 240               	/* epilogue start */
 241               	.LBE36:
 242               	.LBE35:
  27:src/PwmBrushless.c **** 
 243               		.loc 1 27 0
 244 0104 DF91      		pop r29
 245 0106 CF91      		pop r28
 246               	.LVL13:
 247 0108 0895      		ret
 248               		.cfi_endproc
 249               	.LFE12:
 251               	.global	__floatunsisf
 252               	.global	__mulsf3
 253               	.global	__addsf3
 254               	.global	__fixunssfsi
 255               	.global	__floatsisf
 256               	.global	Brushless_Update
 258               	Brushless_Update:
 259               	.LFB14:
  41:src/PwmBrushless.c **** 
  42:src/PwmBrushless.c **** }
  43:src/PwmBrushless.c **** 
  44:src/PwmBrushless.c **** // speed (50 pr - 100 pr)
  45:src/PwmBrushless.c **** void Brushless_Update(can_t* canMsg) {
 260               		.loc 1 45 0
 261               		.cfi_startproc
 262               	.LVL14:
 263 010a FF92      		push r15
 264               	.LCFI2:
 265               		.cfi_def_cfa_offset 3
 266               		.cfi_offset 15, -2
 267 010c 0F93      		push r16
 268               	.LCFI3:
 269               		.cfi_def_cfa_offset 4
 270               		.cfi_offset 16, -3
 271 010e 1F93      		push r17
 272               	.LCFI4:
 273               		.cfi_def_cfa_offset 5
 274               		.cfi_offset 17, -4
 275 0110 CF93      		push r28
 276               	.LCFI5:
 277               		.cfi_def_cfa_offset 6
 278               		.cfi_offset 28, -5
 279 0112 DF93      		push r29
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 7
 282               		.cfi_offset 29, -6
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 5 */
 286               	.L__stack_usage = 5
 287               	.LVL15:
  46:src/PwmBrushless.c **** 
  47:src/PwmBrushless.c ****   size_t i = 0;
  48:src/PwmBrushless.c ****   if(canMsg->id == BRUSHLESS_CANID) {
 288               		.loc 1 48 0
 289 0114 FC01      		movw r30,r24
 290 0116 4081      		ld r20,Z
 291 0118 5181      		ldd r21,Z+1
 292 011a 6281      		ldd r22,Z+2
 293 011c 7381      		ldd r23,Z+3
 294 011e 4335      		cpi r20,83
 295 0120 5D48      		sbci r21,-115
 296 0122 6105      		cpc r22,__zero_reg__
 297 0124 7105      		cpc r23,__zero_reg__
 298 0126 01F0      		breq .+2
 299 0128 00C0      		rjmp .L7
 300 012a FC01      		movw r30,r24
 301               	.LBB37:
  49:src/PwmBrushless.c **** 
  50:src/PwmBrushless.c ****     uint8_t speed = canMsg->data[0];
 302               		.loc 1 50 0
 303 012c F680      		ldd r15,Z+6
 304               	.LVL16:
  51:src/PwmBrushless.c **** 
  52:src/PwmBrushless.c ****     if(speed > CurrentSpeed) {
 305               		.loc 1 52 0
 306 012e C091 0000 		lds r28,CurrentSpeed
 307 0132 0F2D      		mov r16,r15
 308 0134 10E0      		ldi r17,0
 309 0136 CF15      		cp r28,r15
 310 0138 00F4      		brsh .L9
  53:src/PwmBrushless.c ****       for(i = CurrentSpeed; i < speed; i++) {
 311               		.loc 1 53 0
 312 013a D0E0      		ldi r29,0
 313               	.LVL17:
 314               	.L10:
 315               		.loc 1 53 0 is_stmt 0 discriminator 1
 316 013c C017      		cp r28,r16
 317 013e D107      		cpc r29,r17
 318 0140 00F0      		brlo .+2
 319 0142 00C0      		rjmp .L12
  54:src/PwmBrushless.c ****           PWM_SetDuty((uint16_t)(50 + (50.0 / 255.0) * i + 0.5));
 320               		.loc 1 54 0 is_stmt 1 discriminator 3
 321 0144 BE01      		movw r22,r28
 322 0146 80E0      		ldi r24,0
 323 0148 90E0      		ldi r25,0
 324 014a 0E94 0000 		call __floatunsisf
 325               	.LVL18:
 326 014e 29EC      		ldi r18,lo8(-55)
 327 0150 38EC      		ldi r19,lo8(-56)
 328 0152 48E4      		ldi r20,lo8(72)
 329 0154 5EE3      		ldi r21,lo8(62)
 330 0156 0E94 0000 		call __mulsf3
 331               	.LVL19:
 332 015a 20E0      		ldi r18,0
 333 015c 30E0      		ldi r19,0
 334 015e 48E4      		ldi r20,lo8(72)
 335 0160 52E4      		ldi r21,lo8(66)
 336 0162 0E94 0000 		call __addsf3
 337               	.LVL20:
 338 0166 20E0      		ldi r18,0
 339 0168 30E0      		ldi r19,0
 340 016a 40E0      		ldi r20,0
 341 016c 5FE3      		ldi r21,lo8(63)
 342 016e 0E94 0000 		call __addsf3
 343               	.LVL21:
 344 0172 0E94 0000 		call __fixunssfsi
 345               	.LVL22:
 346 0176 CB01      		movw r24,r22
 347 0178 0E94 0000 		call PWM_SetDuty
 348               	.LVL23:
 349               	.LBB38:
 350               	.LBB39:
 351               		.loc 2 163 0 discriminator 3
 352 017c 8FE3      		ldi r24,lo8(-25537)
 353 017e 9CE9      		ldi r25,hi8(-25537)
 354 0180 0197      	1:	sbiw r24,1
 355 0182 01F4      		brne 1b
 356 0184 00C0      		rjmp .
 357 0186 0000      		nop
 358               	.LBE39:
 359               	.LBE38:
  53:src/PwmBrushless.c ****       for(i = CurrentSpeed; i < speed; i++) {
 360               		.loc 1 53 0 discriminator 3
 361 0188 2196      		adiw r28,1
 362               	.LVL24:
 363 018a 00C0      		rjmp .L10
 364               	.LVL25:
 365               	.L9:
  55:src/PwmBrushless.c ****           _delay_ms(10);
  56:src/PwmBrushless.c ****         }
  57:src/PwmBrushless.c ****     } else if(speed < CurrentSpeed) {
 366               		.loc 1 57 0
 367 018c FC16      		cp r15,r28
 368 018e 00F4      		brsh .L13
  58:src/PwmBrushless.c ****       for(i = CurrentSpeed; i > speed; i--) {
 369               		.loc 1 58 0
 370 0190 D0E0      		ldi r29,0
 371               	.LVL26:
 372               	.L14:
 373               		.loc 1 58 0 is_stmt 0 discriminator 1
 374 0192 0C17      		cp r16,r28
 375 0194 1D07      		cpc r17,r29
 376 0196 00F4      		brsh .L12
  59:src/PwmBrushless.c ****         PWM_SetDuty((uint16_t)(50 + (50.0 / 255) * i));
 377               		.loc 1 59 0 is_stmt 1 discriminator 3
 378 0198 BE01      		movw r22,r28
 379 019a 80E0      		ldi r24,0
 380 019c 90E0      		ldi r25,0
 381 019e 0E94 0000 		call __floatunsisf
 382               	.LVL27:
 383 01a2 29EC      		ldi r18,lo8(-55)
 384 01a4 38EC      		ldi r19,lo8(-56)
 385 01a6 48E4      		ldi r20,lo8(72)
 386 01a8 5EE3      		ldi r21,lo8(62)
 387 01aa 0E94 0000 		call __mulsf3
 388               	.LVL28:
 389 01ae 20E0      		ldi r18,0
 390 01b0 30E0      		ldi r19,0
 391 01b2 48E4      		ldi r20,lo8(72)
 392 01b4 52E4      		ldi r21,lo8(66)
 393 01b6 0E94 0000 		call __addsf3
 394               	.LVL29:
 395 01ba 0E94 0000 		call __fixunssfsi
 396               	.LVL30:
 397 01be CB01      		movw r24,r22
 398 01c0 0E94 0000 		call PWM_SetDuty
 399               	.LVL31:
 400               	.LBB40:
 401               	.LBB41:
 402               		.loc 2 163 0 discriminator 3
 403 01c4 EFE3      		ldi r30,lo8(-25537)
 404 01c6 FCE9      		ldi r31,hi8(-25537)
 405 01c8 3197      	1:	sbiw r30,1
 406 01ca 01F4      		brne 1b
 407 01cc 00C0      		rjmp .
 408 01ce 0000      		nop
 409               	.LBE41:
 410               	.LBE40:
  58:src/PwmBrushless.c ****       for(i = CurrentSpeed; i > speed; i--) {
 411               		.loc 1 58 0 discriminator 3
 412 01d0 2197      		sbiw r28,1
 413               	.LVL32:
 414 01d2 00C0      		rjmp .L14
 415               	.LVL33:
 416               	.L13:
  60:src/PwmBrushless.c ****         _delay_ms(10);
  61:src/PwmBrushless.c ****       }
  62:src/PwmBrushless.c ****     } else {
  63:src/PwmBrushless.c ****       PWM_SetDuty((uint16_t)(50 + (50.0 / 255) * speed));
 417               		.loc 1 63 0
 418 01d4 B801      		movw r22,r16
 419 01d6 110F      		lsl r17
 420 01d8 880B      		sbc r24,r24
 421 01da 990B      		sbc r25,r25
 422 01dc 0E94 0000 		call __floatsisf
 423               	.LVL34:
 424 01e0 29EC      		ldi r18,lo8(-55)
 425 01e2 38EC      		ldi r19,lo8(-56)
 426 01e4 48E4      		ldi r20,lo8(72)
 427 01e6 5EE3      		ldi r21,lo8(62)
 428 01e8 0E94 0000 		call __mulsf3
 429               	.LVL35:
 430 01ec 20E0      		ldi r18,0
 431 01ee 30E0      		ldi r19,0
 432 01f0 48E4      		ldi r20,lo8(72)
 433 01f2 52E4      		ldi r21,lo8(66)
 434 01f4 0E94 0000 		call __addsf3
 435               	.LVL36:
 436 01f8 0E94 0000 		call __fixunssfsi
 437               	.LVL37:
 438 01fc CB01      		movw r24,r22
 439 01fe 0E94 0000 		call PWM_SetDuty
 440               	.LVL38:
 441               	.L12:
  64:src/PwmBrushless.c ****     }
  65:src/PwmBrushless.c **** 
  66:src/PwmBrushless.c ****   CurrentSpeed = speed;
 442               		.loc 1 66 0
 443 0202 F092 0000 		sts CurrentSpeed,r15
 444               	.LVL39:
 445               	.L7:
 446               	/* epilogue start */
 447               	.LBE37:
  67:src/PwmBrushless.c ****   }
  68:src/PwmBrushless.c **** }
 448               		.loc 1 68 0
 449 0206 DF91      		pop r29
 450 0208 CF91      		pop r28
 451 020a 1F91      		pop r17
 452 020c 0F91      		pop r16
 453 020e FF90      		pop r15
 454 0210 0895      		ret
 455               		.cfi_endproc
 456               	.LFE14:
 458               		.local	CurrentSpeed
 459               		.comm	CurrentSpeed,1,1
 460               	.Letext0:
 461               		.file 3 "/usr/lib/avr/include/stdint.h"
 462               		.file 4 "/usr/lib/gcc/avr/4.9.2/include/stddef.h"
 463               		.file 5 "./libs/can/can.h"
 464               		.file 6 "src/Pin.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 PwmBrushless.c
     /tmp/cc9gijm4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9gijm4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9gijm4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9gijm4.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc9gijm4.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9gijm4.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9gijm4.s:12     .text:0000000000000000 PWM_SetDuty
     /tmp/cc9gijm4.s:59     .text:000000000000002c Brushless_Calibration
     /tmp/cc9gijm4.s:129    .text:000000000000006c Brushless_Init
     /tmp/cc9gijm4.s:258    .text:000000000000010a Brushless_Update
                             .bss:0000000000000000 CurrentSpeed

UNDEFINED SYMBOLS
Pin_SetMode
__floatunsisf
__mulsf3
__addsf3
__fixunssfsi
__floatsisf
__do_clear_bss
